---
title: "Movie Rating Predictions"
author: "Felipe Maggi"
date: "14/4/2021"
output: html_document
---


```{r packages, message=FALSE, echo=FALSE}
# Packages

if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(recommenderlab)) install.packages("recommenderlab", repos = "http://cran.us.r-project.org")
if(!require(lubridate)) install.packages("lubridate", repos = "http://cran.us.r-project.org")
if(!require(stringr)) install.packages("stringr", repos = "http://cran.us.r-project.org")
if(!require(ggalt)) install.packages("ggalt", repos = "http://cran.us.r-project.org")
if(!require(ggcorrplot)) install.packages("ggcorrplot", repos = "http://cran.us.r-project.org")
```

```{r libraries, message=FALSE, echo=FALSE}
# Libraries

library(tidyverse)
library(caret)
library(data.table)
library(recommenderlab)
library(dplyr)
library(lubridate)
library(stringr)
library(gridExtra)
library(ggalt)
library(scales)
library(ggcorrplot)
```

```{r data_download, message=FALSE, echo=FALSE}
# Data download #####

dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)
```

```{r data_wrangling, message=FALSE, echo=FALSE}
# Data wrangling #####

ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

# __if using R 3.6 or earlier: #####

# movies <- as.data.frame(movies) %>% 
# mutate(movieId = as.numeric(levels(movieId))[movieId],
# title = as.character(title),
# genres = as.character(genres))

# __if using R 4.0 or later: #######

movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                           title = as.character(title),
                                           genres = as.character(genres))

movielens <- left_join(ratings, movies, by = "movieId")
```

```{r edx_and_validation, message=FALSE, warning=FALSE, echo=FALSE}
# Creation of test and validation sets ######

# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.5 or earlier, use `set.seed(1)`

test_index <- createDataPartition(y = movielens$rating, times = 1, 
                                  p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]

# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>% 
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

```

```{r adding_new_columns, message=FALSE, echo=FALSE}
# ___________________________________########
# ADDING NEW COLUMNS #######
# movie_year, rating_date, rating_year ####
# ___________________________________########

# In order to visualize and filter data for exploration, we will add in the 
# data frame three new columns:
# - movie_year (integer)
# - rating_year (integer)
# - rating_date (YY-MM-DD HH:MM:SS POSIXct format)

# This change also could be useful to add time effects 
# in our final model to enhanced the RMSE results

# Creating and index with short and large movie names (with parenthesis), 
# needed to datawrangling tests
ind <- c(1, 2, 3, 4, 5, 6, 21, 29, 39, 47, 67, 107, 108, 109, 112, 121, 
         122, 123, 124, 128)

# Adding rating_date and rating_year ######
edx <- edx %>% mutate(rating_date = as_datetime(timestamp), 
                      rating_year = as.integer(year(rating_date)))

# Creating the new column "movie_year", extracting year from "title" #####
edx <- edx %>% mutate(movie_year = str_extract(title, "\\(\\d\\d\\d\\d\\)"))

# Removing (parenthesis)  from "movie_year" column ####
movie_years_temp <- edx %>% pull(movie_year)
movie_years_temp <- str_remove_all(movie_years_temp, "\\(")
movie_years_temp <- str_remove(movie_years_temp, "\\)")

# Adding the cleaned "movie_years_temp" to data set #####
edx <- edx %>% 
  mutate(movie_year = as.integer(movie_years_temp))
```

```{r test_and_train, message=FALSE, warning=FALSE, echo=FALSE}
# ___________________________________########
#### TEST SET AND TRAIN SET ########
# ___________________________________########

# Creation of test set y train set from edx data frame ######
# Note that validation set will not be used during training and tuning

# We will use 90% of data to train, and 10% of data to test.

set.seed(1970, sample.kind="Rounding")
test_index <- createDataPartition(y = edx$rating, times = 1, p = 0.1,
                                  list = FALSE)
train_edx <- edx[-test_index,]
test_edx <- edx[test_index,]

# SemiJoin #####

test_edx <- test_edx %>% 
  semi_join(train_edx, by = "movieId") %>% 
  semi_join(train_edx, by = "userId")
```

***

### Abstract

This report explains the process of building a linear model for movie ratings prediction, through which an RMSE of 0.86274 is achieved. For the sake of clarity, we have used a nomenclature similar to the Netflix award-winning model, appropriately adapted. The model takes into account movie effects ($b_i$), user effects ($b_u$), movie year effects ($b_{my}$), rating year effects ($b_{ry}$), and genres effects ($b_g$), and its final expression is
$$Y_{u,i} = mu + b_i + b_u + b_{my} + b_{ry} + b_g + \epsilon_{u,i} $$

***

# 1. Introduction

## 1.1 Datasets description
To build the prediction model, we have used a data frame called *edx*, that contains 9,000,055 rows, with the ratings of 10,677 movies, granted by 68,878 users. 
In addition to the user and movie identifiers (*userId* and *movieId*, respectively), the data frame includes *rating*, *timestamp*, *title* and *genres* variables:

| userId| movieId| rating| timestamp|title                         |genres                                       |
|------:|-------:|------:|---------:|:-----------------------------|:--------------------------------------------|
|      1|     122|      5| 838985046|Boomerang (1992)              |Comedy / Romance                             |
|      1|     185|      5| 838983525|Net, The (1995)               |Action / Crime|Thriller                      |
|      1|     231|      5| 838983392|Dumb & Dumber (1994)          |Comedy                                       |
|      1|     292|      5| 838983421|Outbreak (1995)               |Action / Drama / Sci-Fi / Thriller           |
|      1|     316|      5| 838983392|Stargate (1994)               |Action / Adventure / Sci-Fi                  |


The *edx* data frame was divided in a training set, with the 90% of the data, and a test set, and comes from the *movielens* data frame. 

In turn, *movielens* data frame contains 10,100,000 observations, of which 10% were set aside to create the validation set. It is important to note that the *validation* set was not used for training, nor to calculate the *Root Mean Square Error* (RMSE) of the model during its construction. 

## 1.2 Goals and key steps
Our primary goal was to develop a model capable of achieving an RMSE below 0.86490 but, at the same time, manageable in terms of computational capabilities. In a first approach, we try with "Collaborative Filtering" type models using the *recommenderlab* package. However, and after several tests, we realized that to keep the training and validation times within reasonable ranges, it was necessary to work with a much smaller sample of the "edx" data frame than the original. Faced with this situation, we prefer to test a simpler, more approximate linear model that will enable us to work with the complete data frame. The assumption here is that, although the models available in the recommenderlab package could be more powerful, it is preferable to train a simpler model with more data.

In addition, the approach had other considerable disadvantages for us:

1. The results shown in all the references consulted[^1] [^2] [^3] were very far from our objective in terms of RMSE.
2. Despite having even reviewed the original papers of the package[^4] [^5] , we could not see how to incorporate the results of the models included in it in our final model.
3. The references consulted did not allow us to determine how to apply the model on the complete validation test.
4. Some of the models included in the package are based on techniques related to matrix factorization, Singular Value Decomposition (SVD) and Principal Components Analysis (PCA)[^6]. Our knowledge of them is very introductory. Given the nature of this project, we believe that the appropriate approach is to work on a model that we are able to explain.

After doing an exploratory analysis of the data, we realized that, in addition to the effects of users and movies, it was necessary to include in the model the effects related to the year of the movie, the year in which the rating was made, and the genres of each movie.

Once we decided on a simpler linear approach, we began to build the model step by step, adding components in order. In this way, we could determine the effects of each new element, and build a table with the RMSEs obtained on the test set after each iteration. It was really exciting to see the RMSE go down with each element that was incorporated into the model, indicating that we were on the right track. The order in which we included each element was as follows:

1. Avg. ratings: $mu$
2. Movie effects: $b_i$
3. User effects: $b_u$
4. Movie year effects: $b_{my}$
5. Rating year effects: $b_{ry}$
6. Genres effects: $b_g$

We left the effect of genres for last, because we weren't sure how they would affect the model. On the one hand, we were aware that the genre of the films provides a lot of information and explains an important part of the variability of the data. But, on the other hand, we did not know if its inclusion would add noise to the model. Each movie can belong to several genres (and the possible combinations in the *edx* data frame exceeded 700). 

| userId| movieId| rating|title           |genres                                      |
|------:|-------:|------:|:---------------|:-------------------------------------------|
|      1|     292|      5|Outbreak (1995) |Action / Drama / Sci-Fi / Thriller          |

To deal with the genre of movies, we separate each genre by row. In this way, a film that belongs to four genres (for example: Action, Drama, Sci-Fi, Thriller), is transformed into four different observations for each rating obtained: one for Action, another for Drama, another for Sci-Fi, and another for Thriller. This allows us to calculate the effect of each gender separately but, at the same time, it gives each genre the same rating that the user has given the movie.

| userId| movieId| rating|title           |genres   |
|------:|-------:|------:|:---------------|:--------|
|      1|     292|      5|Outbreak (1995) |Action   |
|      1|     292|      5|Outbreak (1995) |Drama    |
|      1|     292|      5|Outbreak (1995) |Sci-Fi   |
|      1|     292|      5|Outbreak (1995) |Thriller |

It is clear that some genres are liked more than others, and that each user prefers some genres over others. However, a user may like war movies, and comedies, but they don't have to like the combination of comedy and war. Analyzing each gender separately, and not their combinations, we feared that the results would take us away from our goal in terms of RMSE.

Despite our doubts, adding the gender effect to the model, treated in the manner described, represented a very significant improvement in the results on the test set.

Other factors, such as the year the rating was granted, have a much less significant effect. But we decided to keep it in the model because although to a lesser extent, it also contributes to improving the results.

[^1]: https://cran.r-project.org/web/packages/recommenderlab/vignettes/recommenderlab.pdf
[^2]: https://rpubs.com/elias_alegria/intro_recommenderlab    
[^3]: https://rpubs.com/tarashnot/recommender_comparison     

[^4]: https://cran.rstudio.com/web/packages/recommenderlab/recommenderlab.pdf
[^5]: https://cran.r-project.org/web/packages/recommenderlab/vignettes/recommenderlab.pdf

[^6]: https://rafalab.github.io/dsbook/large-datasets.html#factor-analysis   


# 2. Methods and Analysis

## 2.1 Data wrangling

As already described in the introduction, the *edx* data frame presents the variables *userId*, *movieId*, *rating*, *timestamp*, *title*, *genres*.

The title of the film includes the year of release (in parentheses), and the *timestamp* reflects the moment in which a user gave a rating to the film. To explore the effect of these two factors, the first change made to the data frame was to extract the movie's release year from the title and create a new column called *movie_year*. For the same reasons, the *timestamp* was used to create the columns named *rating_date* and *rating_year*. 

Here we show the code used, and a sample of the results (to save space, we have selected the variables *userId*, *movieId*, *rating*, *title*, *rating_year* and *movie_year*, and films with short titles):  


```{r adding_rating_year_movie_year, echo=TRUE, message=FALSE, warning=FALSE}

# Adding rating_date and rating_year #####
edx <- edx %>% mutate(rating_date = as_datetime(timestamp), 
                      rating_year = as.integer(year(rating_date)))

# Creating the new column "movie_year", extracting year from "title" #####
edx <- edx %>% mutate(movie_year = str_extract(title, "\\(\\d\\d\\d\\d\\)"))

# Removing (parenthesis)  from "movie_year" column #####
movie_years_temp <- edx %>% pull(movie_year)
movie_years_temp <- str_remove_all(movie_years_temp, "\\(")
movie_years_temp <- str_remove(movie_years_temp, "\\)")

# Adding the cleaned "movie_years_temp" to data set #####
edx <- edx %>% 
  mutate(movie_year = as.integer(movie_years_temp))

# Review of final results
edx %>% 
  select(userId, movieId, rating, title, rating_year, movie_year) %>% 
  head() %>% 
  filter(movieId == 122 | movieId == 185 | movieId == 292 | movieId == 355) %>% 
  as_tibble()

```


The next change made to the original data frame was the one we have already commented on in the introduction: the separation into rows of the genres of each film. Although this change was not made until practically the end of the model development, we review it here to maintain expository coherence.

To show the code used, we have created a shortened version of the edx dataframe. The application of this code on the complete data frame takes some time.


```{r creating_little_edx_version, echo=TRUE, message=FALSE, warning=FALSE}

# Creating and index with short and large movie names (with parenthesis), 
# needed to datawrangling tests
ind <- c(1, 2, 3, 4, 5, 6, 21, 29, 39, 47, 67, 107, 108, 109, 112, 121, 
         122, 123, 124, 128)

# Creating little version
edx_little <- edx[ind]

```

```{r reviewing_little_edx_version, echo=TRUE, message=FALSE, warning=FALSE}
# Reviewing data
edx_little %>% 
  as_tibble()

```

```{r separating_genres, echo=TRUE, message=FALSE, warning=FALSE}
# Separating genres
edx_little_g  <- edx_little %>% 
  separate_rows(genres, sep = "\\|")
```

```{r reviewing_final_results, echo=TRUE, message=FALSE, warning=FALSE}
# Reviewing final results
edx_little_g %>% 
    as_tibble()

```

## 2.2 Data exploration

Our first steps with the *recommenderlab* package focused on creating the rating matrix, and displaying it. Regardless of the use or not of the package in the final model, this allows us to visualize a part of the data to get an idea of its nature.


```{r matrix_creation, message=FALSE, warning=FALSE, echo=FALSE}
# Matrix creation #######

matrix_edx <- edx[1:1000000,] %>% 
  select(userId, movieId, rating)

rec_matrix_edx <- matrix_edx %>% as("realRatingMatrix")

```


```{r matrix_visualization, fig.align='center', message=FALSE, echo=FALSE}
# Matrix visualization #######

image(rec_matrix_edx[1:50,1:50])
```

Ratings range from 0.5 to 5. With 50 movies rated by 50 users, we can already see several things:

1. There are users (rows) who rate more than others, and there are users who rate very few movies.
2. There are movies (columns) that are rated more than others, and there are movies that get very few ratings.
3. There are movies that tend to be rated better than others.
4. Although in this visualization it is not very evident, there are users who tend to give higher ratings than others.

The first two points already tell us that regularization (the penalty of estimates created from small samples) is an element that must be taken into account in the construction of the model.